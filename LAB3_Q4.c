#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//GLOBAL VARIABLES

const float diameter = 58.0, tolerance = .5;
const float circumference = (PI * diameter), rads = 6.2, desiredDistanceMM = 500, k = 2, desiredRightSpeed, desiredLeftSpeed; //angleIncrease is the equivalent of 1 degree in radians
float erightError, leftError;
float degreesTurned, currentLeftDis = 0, currentRightDis=0, speedRight=0, speedLeft=0;

const int motorControlTaskDelay = 1000, k=1, slewRate = 10, increment=1;
int currentPower = 0, desiredPower, leftError, rightError;




task disRight(){
	while(true){

			desiredRightSpeed = k*(desiredDistanceMM - currentRightDis);
			speedRight = (((getMotorRPM(RIGHT) * rads)/secs) * sgn(getMotorSpeed(RIGHT))) * (2*PI);

			rightError = desiredDistanceMM - currentRightDis;
			displayTextLine(1,"%s: %f","speedRight", speedRight);
			displayTextLine(2,"%s: %f","desiredRightSpeed", desiredRightSpeed);
			displayTextLine(3,"%s: %f","rightError", rightError);
			displayTextLine(4,"%s: %f","currentRightDis", currentRightDis);
			displayTextLine(5,"%s: %f","desiredDistanceMillimeters", desiredDistanceINCHES);

			if(abs(errorRight) < tolerance){
				if(currentRightDis < (1/2 * (desiredDistanceMM))){
						if(speedRight < desiredRightSpeed)
								speedRight += slewRate;
						}
				else if(currentRightDis > 1/2 * (desiredDistanceMM)){
								speedRight -= slewRate;
				}
			}

			Increment++;
			currentRightDis = (360/(58 * PI))* Increment;
	}
}
task disLeft(){
	while(true){

			speedLeft = (((getMotorRPM(LEFT) * rads)/secs) * sgn(getMotorSpeed(LEFT))) * (2*PI);
			desiredLeftSpeed = k*(desiredDistanceINCHES - currentLeftDis);

			errorLeft = desiredDistanceMM - currentLeftDis;

			if(abs(rightError)< tolerance){
				if(currentDistanceLeft < 1/2 * (desiredDistanceMM)){
						if(speedLeft < desiredRightSpeed)
								speedLeft += slewRate;
					}
				else if(currentLeftDis > 1/2 * (desiredDistanceMM)){
								speedLeft -= slewRate;
				}
			}

			Increment++;
			currentDistanceLeft = ((58 * PI)/360)* Increment;
	}
}

task main()
{
	startTask(disRight);
	startTask(disLeft);

	while(true){
		setMotorSyncEncoder(RIGHT,LEFT,0,currentRightDis,speedRight);
		setMotorSyncEncoder(LEFT,RIGHT,0,currentLeftDis,speedLeft);
		sleep(motorControlTaskDelay);
	}

}

